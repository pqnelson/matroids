environ

 vocabularies ORDINAL4, FUNCSDOM, TREES_1, NUMBERS, TARSKI, PRE_POLY,
      PRE_TOPC, SUBSET_1, BVFUNC_2, RCOMP_1, SETFAM_1, CLASSES1,
      FINSEQ_1, FINSEQ_2, FINSET_1, CARD_1, ARYTM_3, XBOOLE_0, STRUCT_0,
      ALGSTR_0, ZFMISC_1, NAT_1, INCSP_1, XXREAL_0, TAXONOM2,
      AOFA_000, ORDERS_1, FUNCT_1, RELAT_1, NATTRA_1, EQREL_1,
      VECTSP_1, VECTSP_2, RLVECT_1, RLVECT_3, CARD_3, RLVECT_2, SUPINF_2,
      REALSET1, BINOP_1, FREEALG, ARYTM_1, RLVECT_5, JORDAN13,
      FUNCT_2, VECTSP13, CAT_1, GOBOARD5, WELLORD1, PRELAMB, MESFUNC1,
      MATRIX_0, MATRIX_1, MATRIX_3, MATRIX12, MATRIX13, MATROID0,
      MATROID1;

 notations TARSKI, XBOOLE_0, ZFMISC_1, SUBSET_1, DOMAIN_1, SETFAM_1,
      FINSET_1, FINSEQ_1, FINSEQ_2, ORDINAL1, NUMBERS, RELAT_1,
      FUNCT_1, RELSET_1, PARTFUN1, FUNCT_2, EQREL_1, ORDERS_1,
      TAXONOM2, XCMPLX_0, XXREAL_0, NAT_1, CARD_1, NAT_D, CLASSES1,
      AOFA_000, STRUCT_0, ALGSTR_0, GROUP_1, RLVECT_1, VECTSP_1,
      VECTSP_6, VECTSP_7, PRE_TOPC, TDLAT_3, MATRLIN, MATRIX_0,
      MATRIX_1, MATRIX_3, MATRIX12, MATRIX13, MATRIX15, VECTSP13,
      PENCIL_1, RANKNULL, MATROID0;

 constructors FVSUM_1, FINSEQ_1, NAT_D, PARTFUN1, STRUCT_0, COH_SP,
      TDLAT_3, TAXONOM2, RANKNULL, VECTSP_7, PENCIL_1, MATRIX_1,
      MATRIX_3, MATRIX12, MATRIX13, MATRLIN, MATRIX15, VECTSP13,
      REALSET1, RELSET_1, MATROID0;

 registrations FINSEQ_1, FINSEQ_2, FUNCT_1, FINSET_1, CARD_1, RELSET_1,
      PARTFUN1, FUNCT_2, STRUCT_0, SUBSET_1, PENCIL_1, TDLAT_3,
      SETFAM_1, EQREL_1, MATRIX_1, MATRLIN, XREAL_0, ALGSTR_0, BINOM,
      RLVECT_1, VECTSP_1, VECTSP_7, VECTSP13, ORDINAL1, MATROID0,
      MATRIX13;

 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

 definitions TARSKI, FINSEQ_1, FUNCT_1, CLASSES1, TAXONOM2, XBOOLE_0,
      STRUCT_0, PENCIL_1, FINSET_1, MATRIX_1, MATROID0;

 equalities XBOOLE_0, STRUCT_0, ORDINAL1, MATROID0;

 expansions TARSKI, FUNCT_1, XBOOLE_0, STRUCT_0, PENCIL_1, MATRIX_1,
      MATROID0;

 theorems TARSKI, XBOOLE_1, ZFMISC_1, CARD_1, COH_SP, PRE_TOPC, NAT_1,
      CLASSES1, SUBSET_1, TDLAT_3, XXREAL_0, XREAL_1, XBOOLE_0, FINSEQ_1,
      FINSEQ_2, SETFAM_1, TAXONOM2, ORDERS_1, PARTFUN1, FUNCT_2,
      FUNCT_1, RELAT_1, EQREL_1, WELLORD2, VECTSP_7, VECTSP_9,
      MATRIX_0, MATRIX_1, MATRIX_3, MATRLIN, MATRIX12, CARD_2,
      VECTSP_4, ORDINAL1, CARD_FIL, RANKNULL, VECTSP_1, VECTSP_6,
      VECTSP13, ALGSTR_0, HALLMAR1, MATROID0;

 schemes FUNCT_2, NAT_1, SUBSET_1;

begin :: Isomorphic matroids

:: Oxley, "Matroid Theory", Example 1.1.8
definition
  let M1,M2 be Matroid;
  pred M1,M2 are_isomorphic means :Def1:
  ex psi being Function of M1,M2
  st psi is one-to-one & psi is onto
   & for X being Subset of M1
     for Y being Subset of M2 st Y = psi .: X
     holds X is independent iff Y is independent;
end;

theorem Th1:
  for M being Matroid
  holds M,M are_isomorphic
proof
  let M be Matroid;
  take psi = id M;
  thus thesis by FUNCT_1:92;
end;

theorem Th2:
  for M1,M2,M3 being Matroid
  st M1,M2 are_isomorphic & M2,M3 are_isomorphic
  holds M1,M3 are_isomorphic
proof
  let M1,M2,M3 be Matroid;
  assume A1: M1,M2 are_isomorphic;
  assume A2: M2,M3 are_isomorphic;
  consider psi1 being Function of M1,M2 such that
  A3: psi1 is one-to-one & psi1 is onto
   & for X being Subset of M1
     for Y being Subset of M2 st Y = psi1 .: X
     holds X is independent iff Y is independent
  by A1;
  consider psi2 being Function of M2,M3 such that
  A4: psi2 is one-to-one & psi2 is onto
   & for Y being Subset of M2
     for Z being Subset of M3 st Z = psi2 .: Y
     holds Y is independent iff Z is independent
  by A2;
  reconsider psi3 = psi2 * psi1 as Function of M1, M3;
  take psi3;
  A5: psi3 is one-to-one & psi3 is onto by A3,A4,FUNCT_2:27;
  for X being Subset of M1
  for Z being Subset of M3 st Z = psi3 .: X
  holds X is independent iff Z is independent
  proof
    let X be Subset of M1;
    let Z be Subset of M3;
    assume Z = psi3 .: X;
    then Z = psi2 .: (psi1 .: X) by RELAT_1:126;
    then Z is independent iff psi1 .: X is independent by A4;
    hence thesis by A3;
  end;
  hence thesis by A5;
end;

theorem Th3:
  for M1,M2 being Matroid
  st M1,M2 are_isomorphic
  holds M2,M1 are_isomorphic
proof
  let M1,M2 be Matroid;
  assume M1,M2 are_isomorphic;
  then consider psi being Function of M1,M2 such that
  A1: psi is one-to-one & psi is onto
   & for X being Subset of M1
     for Y being Subset of M2 st Y = psi .: X
     holds X is independent iff Y is independent;
  ex phi being Function of M2,M1
  st phi is one-to-one & phi is onto
  & for Y being Subset of M2
    for X being Subset of M1 st X = phi .: Y
    holds Y is independent iff X is independent
  proof
    A2: rng psi = the carrier of M2 by A1,FUNCT_2:def 3;
    then reconsider phi = psi" as Function of M2,M1 by A1,FUNCT_2:25;
    take phi;
    A3: psi * phi = id (the carrier of M2) by A1,A2,FUNCT_2:29;
    then phi is one-to-one & psi is onto by FUNCT_2:23;
    hence phi is one-to-one;
    A4: phi * psi = id (the carrier of M1) by A1,A2,FUNCT_2:29;
    then psi is one-to-one & phi is onto by FUNCT_2:23;
    hence phi is onto;
    let Y be Subset of M2;
    let X be Subset of M1;
    assume A5: X = phi .: Y;
    A6: psi .: X = psi .: (phi .: Y) by A5
                .= (psi * phi) .: Y by RELAT_1:126
                .= (id the carrier of M2) .: Y by A3
                .= Y by FUNCT_1:92;
    hereby 
      assume Y is independent;
      hence X is independent by A1,A6;
    end;
    assume X is independent;
    hence Y is independent by A1,A6;
  end;
  hence thesis;
end;


definition
  let M1, M2 be Matroid;
  redefine pred M1,M2 are_isomorphic;
  reflexivity by Th1;
  symmetry by Th3;
end;

theorem Th4:
  for M1,M2 being Matroid st M1 = M2
  holds M1,M2 are_isomorphic;

begin :: Vector matroids

reserve R for Ring; :: non empty doubleLoopStr;
reserve A for Matrix of R;

definition
  let R, A;
  func columns A -> Subset of R ^* (len A) equals
  {Col(A,i) where i is Nat : i in Seg (width A)};
  coherence
  proof
    set IT = {Col(A,i) where i is Nat : i in Seg (width A)};
    for x being object
    st x in IT
    holds x in the carrier of R ^* (len A)
    proof
      let x be object;
      assume A1: x in IT;
      then consider i being Nat such that
      A2: x = Col(A,i) & i in Seg (width A);
      x in (len A)-tuples_on the carrier of R by A2;
      hence x in the carrier of R ^* (len A) by VECTSP13:def 7;
    end;
    then IT c= the carrier of R ^* (len A);
    then IT in bool the carrier of (R ^* (len A));
    then IT is Element of bool the carrier of (R ^* (len A));
    then IT is Subset of the carrier of R ^* (len A);
    hence thesis;
  end;
end;

registration
  let R, A;
  cluster columns A -> finite;
  coherence;
::>       *4
end;

theorem Th5:
  for c being object
  holds c in columns A
  iff ex i being Nat st c = Col(A, i) & i in Seg(width A)
proof
  let c be object;
  hereby 
    assume c in columns A;
    then consider i being Nat such that
    A1: c = Col(A,i) & i in Seg (width A);
    take i;
    thus c = Col(A, i) by A1;
    thus i in Seg(width A) by A1;
  end;
  given i being Nat such that 
  A2: c = Col(A, i) & i in Seg(width A);
  thus c in columns A by A2;
end;

theorem
  for m,n being Nat
  for A being Matrix of m,n,R
  holds columns A is Subset of R ^* m
  by MATRIX_0:def 2;

definition
  let R;
  let I be set;
  let A;
  func I -indexed_columns_of A -> Subset of R ^* (len A) equals :DefFoo:
  {Col(A,i) where i is Nat : i in I};
  coherence
  proof
    set IT = {Col(A,i) where i is Nat : i in I};
    for x being object
    st x in IT
    holds x in the carrier of R ^* (len A)
    proof
      let x be object;
      assume A1: x in IT;
      then consider i being Nat such that
      A2: x = Col(A,i) & i in I;
      x in (len A)-tuples_on the carrier of R by A2;
      hence x in the carrier of R ^* (len A) by VECTSP13:def 7;
    end;
    then IT c= the carrier of R ^* (len A);
    then IT in bool the carrier of (R ^* (len A));
    then IT is Element of bool the carrier of (R ^* (len A));
    then IT is Subset of the carrier of R ^* (len A);
    hence thesis;
  end;
end;

theorem Th22:
  for I being set
  for C being object
  holds C in I-indexed_columns_of A
    iff ex i being Nat st i in I & C = Col(A,i)
proof
  let I be set;
  let C be object;
  thus C in I-indexed_columns_of A implies
  ex i being Nat st i in I & C = Col(A,i)
  proof
    assume C in I-indexed_columns_of A;
    then consider i being Nat such that
    A1: C = Col(A,i) & i in I by DefFoo;
    take i;
    thus i in I by A1;
    thus C = Col(A,i) by A1;
  end;
  thus (ex i being Nat st i in I & C = Col(A,i))
  implies C in I-indexed_columns_of A;
end;

:: Compare this to LinearlyIndependentSubsets V (MATROID0:def 9)
definition
  let R, A;
  func vector_matroid A -> strict SubsetFamilyStr means :Def3:
  the carrier of it = Seg (width A) &
  the_family_of it = {I where I is Subset of Seg(width A) :
                      I-indexed_columns_of A is linearly-independent };
  existence
  proof
    defpred P[set] means $1-indexed_columns_of A is linearly-independent;
    set Fam = { I where I is Subset of Seg (width A) : P[I] };

    Fam is Element of bool (bool (Seg (width A)))
    proof
      for F being object st F in Fam holds F in bool (Seg (width A))
      proof
        let F be object;
        assume F in Fam;
        then ex I being Subset of Seg (width A) st I = F & P[I];
        hence F in bool (Seg (width A));
      end;
      then Fam c= bool (Seg (width A));
      then Fam in bool (bool (Seg (width A)));
      hence thesis;
    end;
    then reconsider Fam as Subset-Family of Seg (width A);
    reconsider M = TopStruct(# Seg(width A), Fam #) as strict SubsetFamilyStr;
    take M;
    thus thesis;
  end;
  uniqueness;
end;

theorem Th29:
  for I being Subset of Seg(width A)
  holds I in the_family_of vector_matroid A
    iff I-indexed_columns_of A is linearly-independent
proof
  let I be Subset of Seg(width A);
  thus I in the_family_of vector_matroid A implies
       I-indexed_columns_of A is linearly-independent
  proof
    assume I in the_family_of vector_matroid A;
    then I in {I9 where I9 is Subset of Seg(width A) :
               I9-indexed_columns_of A is linearly-independent }
    by Def3;
    then ex I9 being Subset of Seg(width A)
    st I = I9 & I9-indexed_columns_of A is linearly-independent;
    hence I-indexed_columns_of A is linearly-independent;
  end;
  thus I-indexed_columns_of A is linearly-independent implies
       I in the_family_of vector_matroid A
  proof
    assume A1: I-indexed_columns_of A is linearly-independent;
    then ex I9 being Subset of Seg(width A)
    st I = I9 & I9-indexed_columns_of A is linearly-independent;
    then I in {I9 where I9 is Subset of Seg(width A) :
               I9-indexed_columns_of A is linearly-independent };
    hence I in the_family_of vector_matroid A by Def3;
  end;
end;

theorem Th30a:
  for I1,I2 being Subset of Seg(width A)
  st I1 c= I2
  holds I1-indexed_columns_of A c= I2-indexed_columns_of A
proof
  let I1,I2 be Subset of Seg(width A);
  assume A1: I1 c= I2;
  for x being object st x in I1-indexed_columns_of A
  holds x in I2-indexed_columns_of A
  proof
    let x be object;
    assume A2: x in I1-indexed_columns_of A;
    then consider i being Nat such that
    A3: i in I1 & x = Col(A, i)
    by Th22;
    i in I2 by A1,A3;
    hence x in I2-indexed_columns_of A by A3,Th22;
  end;
  hence I1-indexed_columns_of A c= I2-indexed_columns_of A;
end;

theorem Th30:
  for I1,I2 being Subset of Seg(width A)
  st I1 c= I2 & I2-indexed_columns_of A is linearly-independent
  holds I1-indexed_columns_of A is linearly-independent
proof
  let I1,I2 be Subset of Seg(width A);
  assume A1: I1 c= I2;
  assume A2: I2-indexed_columns_of A is linearly-independent;
  I1-indexed_columns_of A c= I2-indexed_columns_of A by A1, Th30a;
  hence I1-indexed_columns_of A is linearly-independent by A2, VECTSP_7:1;
end;

theorem Th31:
  for I1,I2 being set
  st I1 c= I2 & I2 is Subset of Seg(width A)
  holds I1 is Subset of Seg(width A)
proof
  let I1,I2 be set;
  assume A1: I1 c= I2;
  assume A2: I2 is Subset of Seg(width A);
  for x being object st x in I1 holds x in Seg(width A)
  proof
    let x be object;
    assume x in I1;
    then x in I2 by A1, TARSKI:def 5;
    hence x in Seg(width A) by A2, TARSKI:def 5;
  end;
  then I1 c= Seg(width A) by TARSKI:def 5;
  hence I1 is Subset of Seg(width A);
end;

theorem Th34a:
  for I1,I2 being set
  st I1 c= I2 & I2 in the_family_of vector_matroid A
  holds I1 in the_family_of vector_matroid A
proof
  defpred P[set] means $1-indexed_columns_of A is linearly-independent;
  let I1,I2 be set;
  assume A1: I1 c= I2;
  assume A2: I2 in the_family_of vector_matroid A;
  then I2 in {I where I is Subset of Seg(width A) :
  I-indexed_columns_of A is linearly-independent } by Def3;
  then A3: ex J2 being Subset of Seg(width A) st I2 = J2 & P[J2];
  then reconsider J2 = I2 as Subset of Seg(width A);
  I2 = J2 & J2 is Subset of Seg(width A);
  then reconsider J1 = I1 as Subset of Seg(width A) by A1, Th31;
  J2-indexed_columns_of A is linearly-independent by A3, Th29;
  then J1-indexed_columns_of A is linearly-independent by A1,Th30;
  then J1 in the_family_of vector_matroid A by Th29;
  hence I1 in the_family_of vector_matroid A;
end;

registration
  let R, A;
  cluster vector_matroid A -> subset-closed;
  correctness
  proof
    for X,Y being set
    st X in the_family_of vector_matroid A & Y c= X
    holds Y in the_family_of vector_matroid A by Th34a;
    then the_family_of vector_matroid A is subset-closed by CLASSES1:def 1;
    hence thesis by MATROID0:def 3;
  end;
end;

registration
  let R, A;
  cluster vector_matroid A -> finite;
  coherence
  proof
    Seg(width A) is finite;
    then the carrier of vector_matroid A is finite by Def3;
    hence thesis;
  end;
end;

theorem ThWithExchangeProperty:
  for U1,U2 being finite Subset of vector_matroid A
  st U1 in the_family_of vector_matroid A
  & U2 in the_family_of vector_matroid A
  & card U2 = card U1 + 1
  ex b being Element of vector_matroid A
  st b in U2 \ U1 & U1 \/ {b} in the_family_of vector_matroid A
proof
  let U1,U2 be finite Subset of vector_matroid A;
  assume A1: U1 in the_family_of vector_matroid A;
  assume A2: U2 in the_family_of vector_matroid A;
  assume A3: card U2 = card U1 + 1;
  then A4: card U1 < card U2 by NAT_1:13;
  then consider b being set such that
  A5: b in U2 \ U1 by MATROID0:5;
  b in U2 by A5, XBOOLE_0:def 5;
  then b in vector_matroid A;
  then reconsider b9 = b as Element of vector_matroid A;
  take b9;
  thus b9 in U2 \ U1 by A5;
  thus U1 \/ {b9} in the_family_of vector_matroid A;
::>                                               *4
end;

registration
  let R, A;
  cluster vector_matroid A -> non empty;
  correctness;
::>         *4
  cluster vector_matroid A -> non void;
  correctness;
::>         *4
  cluster vector_matroid A -> with_exchange_property;
  correctness by ThWithExchangeProperty, MATROID0:def 4;
  cluster vector_matroid A -> finite-degree;
  correctness;
end;

:: Double check the registrations work
theorem
  vector_matroid A is Matroid;

:: The [matrix] rank of a matroid representation (viewed as a matrix) = the
:: [matroid] rank of the vector matroid of the matrix
theorem
  the_rank_of A = Rnk (vector_matroid A);
::>                                    *4,4

begin :: Representations

definition
  let R;
  let IT be Matroid;
  attr IT is R-representable means :Def4:
  ex A being Matrix of R
  st IT, vector_matroid A are_isomorphic;
end;

registration
  let R, A;
  cluster vector_matroid A -> R-representable;
  correctness;
end;

registration
  let R;
  cluster R-representable for Matroid;
  existence
  proof
    set A = the Matrix of R;
    take M = vector_matroid A;
    thus thesis;
  end;
end;

reserve M for R-representable Matroid;

definition
  let R,A,M;
  pred A represents M means :Def5:
  M, vector_matroid A are_isomorphic;
end;

definition
  let R,M,A;
  attr A is M-representation means :Def6:
  A represents M;
end;

registration
  let R,M;
  cluster M-representation for Matrix of R;
  existence
  proof
    consider A being Matrix of R such that
    A1: M, vector_matroid A are_isomorphic
    by Def4;
    take A;
    thus thesis by A1,Def5;
  end;
end;

definition
  let R,M;
  mode Representation of M is M-representation Matrix of R;
end;

theorem Th9:
  for M1,M2 being R-representable Matroid st M1,M2 are_isomorphic
  for A being Matrix of R st A represents M1
  holds A represents M2
proof
  let M1,M2 be R-representable Matroid;
  assume A1: M1,M2 are_isomorphic;
  let A be Matrix of R;
  assume A2: A represents M1;
  then M1, vector_matroid A are_isomorphic;
  then M2, vector_matroid A are_isomorphic by A1, Th2;
  hence A represents M2;
end;

theorem Th10:
  for M1,M2 being R-representable Matroid st M1,M2 are_isomorphic
  for A being Representation of M1
  holds A represents M2
proof
  let M1,M2 be R-representable Matroid;
  assume A1: M1,M2 are_isomorphic;
  let A be Representation of M1;
  A represents M1 by Def6;
  hence A represents M2 by A1, Th9;
end;

:: Oxley, "Matroid Theory", Chapter 2, section 2 opens with the
:: observation that if A is an m-by-n matrix of F, and if M[A] is a
:: vector_matroid of A, then M[A] does not uniquely determine A.
:: The following operations leaves M invariant:

:: Oxley 2.2.1
theorem Th11:
  for m,n being Nat
  for M being R-representable Matroid
  for A being Matrix of m,n,R st A represents M
  for l,k being Nat
  holds InterchangeLine(A, l, k) represents M;
::>                                         *4

:: Oxley 2.2.2
theorem Th12:
  for m,n being Nat
  for M being R-representable Matroid
  for A being Matrix of m,n,R st A represents M
  for l being Nat
  for a being Element of R st a <> 0.R
  holds ScalarXLine(A, l, a) represents M;
::>                                     *4,4

:: Oxley 2.2.3
theorem Th13:
  for m,n being Nat
  for M being R-representable Matroid
  for A being Matrix of m,n,R st A represents M
  for l,k being Nat st k in dom A
  for a being Element of R st a <> 0.R
  holds RlineXScalar(A, l, k, a) represents M;
::>                                         *4,4

:: Oxley 2.2.4
:: NB: "A ^ B" is Mizar notation for \begin{pmatrix}A\\\hrule B\end{pmatrix}
:: (adjoining the rows of B after the rows of A).
theorem Th14:
  for l,m,n being Nat
  for M being R-representable Matroid
  for A being Matrix of m,n,R
  holds A represents M iff A ^ 0.(R,l,n) represents M;
::>                                                 *4,4

:: Oxley 2.2.5
theorem Th15:
  for m,n being Nat st m > 0 & n > 0
  for M being R-representable Matroid
  for A being Matrix of m,n,R st A represents M
  for l,k being Nat st l in Seg(width A) & k in Seg(width A)
  holds InterchangeCol(A, l, k) represents M;
::>                                        *4

:: Oxley 2.2.6 --- not needed to prove every rep yields a standard rep
theorem Th16:
  for m,n being Nat st m > 0 & n > 0
  for M being R-representable Matroid
  for A being Matrix of m,n,R st A represents M
  for l being Nat st l in Seg(width A)
  for a being Element of R st a <> 0.R
  holds ScalarXCol(A, l, a) represents M;
::>                                    *4,4

:: Oxley 2.2.7 notes that replacing each matrix entry by its image
:: under some automorphism of F produces another matrix A2
:: such that A2 represents M...but it is not used in Chapter 2 (or
:: needed until Chapter 6)...so I am ignoring it.

:: Oxley Chapter 2, Section 2, offers the following prose describing
:: the proof (pp.77--78):
:: \begin{quote}
:: Assume that the matrix $A$ is non-zero. It is well known and not
:: difficult to check that, by a sequence of operations of types
:: 2.2.1--2.2.5, one can reduce $A$ to the form $[I_{r}|D]$ where $I_{r}$
:: is the $r\times r$ identity matrix and $D$ is some $r\times(n-r)$
:: matrix over $F$. Evidently $r = r(M)$. Suppose that the columns of
:: $[I_{r}|D]$ are labelled, in order, $e_{1}$, $e_{2}$, \dots,
:: $e_{n}$. Then $\{e_{1}, e_{2}, \dots, e_{r}\}$ is a basis $B$ of
:: $M$. Moreover, it is natural to label the rows of $D$, in order, by
:: $e_{1}$, $e_{2}$, \dots, $e_{r}$. Thus $M[A]$ can be represented, as
:: in Figure 2.5, both by the matrix $[I_{r}|D]$, whose columns are
:: labelled $e_{1}$, $e_{2}$, \dots, $e_{n}$, and by the matrix $D$,
:: whose rows are labelled $e_{1}$, $e_{2}$, \dots, $e_{r}$ and whose
:: columns are labelled $e_{r+1}$, $e_{r+2}$, \dots, $e_{n}$. We shall
:: refer to both $[I_{r}|D]$ and $D$ as \emph{standard representative matrices}
:: for $M$ and will sometimes add \emph{with respect to $\{e_{1}, e_{2}, \dots,
:: e_{r}\}$} to this description. To limit possible ambiguities with this
:: terminology, we shall also refer to $D$ as a \emph{reduced standard
:: representative matrix}. Note that, in $[I_{r}|D]$, only the columns are
:: labelled, whereas both the rows and columns are labelled in $D$.
:: \end{quote}


:: Following the conventions of the paper, I am defining the "standard"
:: representation to be the matrix D such that [I_{r} | D] is the
:: "full" representation
definition
  let R;
  let M; :: be R-representable Matroid;
  let IT be Representation of M;
  attr IT is full means :Def7:
  ex D being Matrix of R
  st IT = 1.(R,len IT) ^^ D; :: = [I_{r} | D] in block form
end;

begin :: Gaussian elimination

:: pivot_index(i,A) = 0 or pivot_index(i,A) is the column index
:: for the pivot in row i of A
definition
  let R be non empty ZeroStr;
  let A be Matrix of R;
  let i be Nat;
  func pivot_index (i,A) -> Nat means
  it = 0 if (for j being Nat st [i,j] in Indices A holds A * (i,j) = 0.R)
  otherwise ([i,it] in Indices A
             & A * (i, it) <> 0.R
             & for j being Nat st [i,j] in Indices A & j < it
               holds A * (i,j) = 0.R);
  existence
  proof
    thus (for j being Nat st [i,j] in Indices A holds A * (i,j) = 0.R) implies
    ex k being Nat st k = 0;
    defpred P[Nat] means [i,$1] in Indices A & A * (i, $1) <> 0.R;
    assume A1: ex j being Nat st P[j];
    consider k being Nat such that
    A2: P[k] & for n being Nat st P[n] holds k <= n
    from NAT_1:sch 5(A1);
    take k;
    thus thesis by A2;
  end;
  uniqueness
  proof
    defpred P[Nat] means ([i,$1] in Indices A
                          & A * (i, $1) <> 0.R
                          & for j being Nat st [i,j] in Indices A & j < $1
                            holds A * (i,j) = 0.R);
    let k1,k2 being Nat;
    thus (for j being Nat st [i,j] in Indices A holds A * (i,j) = 0.R)
    & k1 = 0 & k2 = 0 implies k1 = k2;

    defpred P9[Nat] means [i,$1] in Indices A & A * (i, $1) <> 0.R;
    assume ex j being Nat st P9[j];
    assume A3: P[k1];
    assume A4: P[k2];
    k1 <> k2 implies contradiction
    proof
      assume k1 <> k2;
      then k1 < k2 or k2 < k1 by XXREAL_0:1;
      hence thesis by A3,A4;
    end;
    hence thesis;
  end;
  consistency;
end;

definition
  let R be non empty ZeroStr;
  let A be Matrix of R;
  let i be Nat;
  func pivot (i, A) -> Element of R equals
  A * (i, (pivot_index (i,A))) if [i, pivot_index (i,A)] in Indices A
  otherwise 0.R;
  coherence;
  consistency;
end;

definition
  let R be non empty ZeroStr;
  let A be Matrix of R;
  pred A in_row_echelon_form means
  ex k being Nat st
  for i being Nat st i in Seg(len A)
  holds (i >= k implies Line(A, i) = (width A) |-> 0.R)
  & (i + 1 < k implies pivot_index(i, A) < pivot_index(i + 1, A));
end;

definition
  let R be non empty ZeroOneStr;
  let A be Matrix of R;
  pred A in_reduced_row_echelon_form means
  A in_row_echelon_form
  & for i being Nat st i in Seg(len A)
    holds (pivot(i, A) = 1.R
           & for j being Nat
             st [i,j] in Indices A & j <> pivot_index(i,A)
             holds A * (i,j) = 0.R)
          or (Line(A, i) = (width A) |-> 0.R);
end;

definition
  let R be non empty doubleLoopStr;
  let IT be Matrix of R;
  attr IT is elementary_row means
  (ex m,l,k being Nat st IT = InterchangeLine(1.(R,m),l,k))
  or (ex m,l being Nat, a being Element of R
      st IT = ScalarXLine(1.(R,m), l, a))
  or (ex m,k,l being Nat, a being Element of R
      st IT = RlineXScalar(1.(R,m), l, k, a));
end;

registration
  let R be non empty doubleLoopStr;
  let m,l,k be Nat;
  cluster InterchangeLine(1.(R,m),l,k) -> elementary_row;
  correctness;
  let a be Element of R;
  cluster RlineXScalar(1.(R,m), l, k, a) -> elementary_row;
  correctness;
  cluster RlineXScalar(1.(R,m), l, k, a) -> elementary_row;
  correctness;
end;

:: MATRIX12:6,7,8 relating elementary_row Matrix to row operations on matrices
registration
  let R be non empty doubleLoopStr;
  cluster elementary_row for Matrix of R;
  existence
  proof
    set m = the Nat;
    take InterchangeLine(1.(R,m),m,m);
    thus thesis;
  end;
  let m be Nat;
  cluster elementary_row for Matrix of m,R;
  existence
  proof
    take InterchangeLine(1.(R,m),m,m);
    thus thesis;
  end;
end;

theorem Th17:
  for R being non empty doubleLoopStr
  for m being Nat
  holds ILine(1.(R,m),m,m) = 1.(R,m)
proof
  let R be non empty doubleLoopStr;
  let m be Nat;
  A1: for i,j being Nat st [i,j] in Indices 1.(R,m)
  holds ILine(1.(R,m),m,m) * (i,j) = 1.(R,m) * (i,j)
  proof
    let i,j be Nat;
    assume [i,j] in Indices 1.(R,m);
    then [i,j] in [:dom(1.(R,m)),Seg(width 1.(R,m)):] by MATRIX_0:def 4;
    then A2: i in dom 1.(R,m) & j in Seg(width 1.(R,m))
    by ZFMISC_1:87;
    then i = m implies ILine(1.(R,m), m, m) * (i,j) = 1.(R,m) * (m,j)
    by MATRIX12:def 1;
    hence ILine(1.(R,m),m,m) * (i,j) = 1.(R,m) * (i,j) by A2, MATRIX12:def 1;
  end;
  len ILine(1.(R,m),m,m) = len 1.(R,m)
  & width ILine(1.(R,m),m,m) = width 1.(R,m)
  by MATRIX12:1,def 1;
  hence ILine(1.(R,m),m,m) = 1.(R,m) by A1, MATRIX_0:21;
end;

registration
  let R be non empty doubleLoopStr;
  let m be Nat;
  cluster 1.(R,m) -> elementary_row;
  correctness
  proof
    ILine(1.(R,m),m,m) = 1.(R,m) by Th17;
    hence thesis;
  end;
end;

reserve F for Skew-Field;
reserve m,n for Nat;

:: If A is already in row echelon form, return the sequence <*1.(R,m)*>
theorem Th18:
  for A being Matrix of F
  ex Fam being FinSequence of (len A)-Matrices_over F
  st len Fam > 0 & Fam.1 is elementary_row Matrix of (len A),F
  & (for i being Nat st 1 < i & i < len Fam
     for Fi being Matrix of (len A),F st Fi = Fam.i
     ex B being elementary_row Matrix of (len A),F
     st Fam.(i + 1) = B * Fi)
  & (ex B being Matrix of (len A),F
     st B = Fam.(len Fam)
      & B * A in_row_echelon_form);
::>                              *4

theorem Th19:
  for A being Matrix of F st A in_row_echelon_form
  for F1 being Matrix of (len A),F
  ex Fam being FinSequence of (len A)-Matrices_over F
  st (for i being Nat st i < len Fam
      for Fi being Matrix of (len A),F
      st ((i = 0 implies Fi = F1) & (i <> 0 implies Fi = Fam.i))
     ex B being elementary_row Matrix of (len A),F
     st ((i+1) in dom Fam implies Fam.(i + 1) = B * Fi))
  & (ex B being Matrix of (len A),F
     st B = Fam.(len Fam)
      & B * A in_reduced_row_echelon_form);
::>                                      *4

:: Gaussian elimination, in all its gory details!
::$N Gaussian Elimination
theorem Th20:
  for A being Matrix of F
  ex Fam being FinSequence of (len A)-Matrices_over F
  st len Fam > 0 & Fam.1 is elementary_row Matrix of (len A),F
  & (for i being Nat st 1 <= i & i < len Fam
     for Fi being Matrix of (len A),F st Fi = Fam.i
     ex B being elementary_row Matrix of (len A),F
     st Fam.(i + 1) = B * Fi)
  & (ex B being Matrix of (len A),F
     st B = Fam.(len Fam)
      & B * A in_reduced_row_echelon_form)
proof
  let A be Matrix of F;
  consider Fam1 being FinSequence of (len A)-Matrices_over F such that
  A1: len Fam1 > 0 & Fam1.1 is elementary_row Matrix of (len A),F and
  A2: for i being Nat st 1 < i & i < len Fam1
      for Fi being Matrix of (len A),F st Fi = Fam1.i
      ex B being elementary_row Matrix of (len A),F
      st Fam1.(i + 1) = B * Fi and
  A3: ex B being Matrix of (len A),F
      st B = Fam1.(len Fam1)
       & B * A in_row_echelon_form
  by Th18;
  consider B1 being Matrix of (len A),F such that
  A4: B1 = Fam1.(len Fam1) & B1 * A in_row_echelon_form
  by A3;
  width B1 = len A by MATRIX_0:24;
  then len (B1 * A) = len B1 by MATRIX_3:def 4
                   .= len A by MATRIX_0:24;
  then consider Fam2 being FinSequence of (len A)-Matrices_over F such that
  A5: (for i being Nat st i < len Fam2
       for Fi being Matrix of (len A),F
       st ((i = 0 implies Fi = B1) & (i <> 0 implies Fi = Fam2.i))
       ex B being elementary_row Matrix of (len A),F
       st ((i+1) in dom Fam2 implies Fam2.(i + 1) = B * Fi))
    & (ex B2 being Matrix of (len A),F
       st B2 = Fam2.(len Fam2)
       & B2 * (B1 * A) in_reduced_row_echelon_form)
  by A4,Th19;
  take Fam = Fam1 ^ Fam2;

  thus len Fam > 0
  proof
    len Fam2 >= 0 by NAT_1:2;
    then (len Fam1) + (len Fam2) > 0 + 0 by A1, XREAL_1:8;
    hence thesis by FINSEQ_1:22;
  end;

  thus Fam.1 is elementary_row Matrix of (len A),F
  proof
    0 < 0 + len Fam1 by A1;
    then 1 <= len Fam1 by NAT_1:19;
    then 1 in Seg (len Fam1) by FINSEQ_1:1;
    then 1 in dom Fam1 by FINSEQ_1:def 3;
    then Fam.1 = Fam1.1 by FINSEQ_1:def 7;
    hence thesis by A1;
  end;
  thus for i being Nat st 1 <= i & i < len Fam
       for Fi being Matrix of (len A),F st Fi = Fam.i
       ex B being elementary_row Matrix of (len A),F
       st Fam.(i + 1) = B * Fi by A2,A3,A5;
::>                             *4
  thus ex B being Matrix of (len A),F
       st B = Fam.(len Fam)
        & B * A in_reduced_row_echelon_form by A2,A3,A4,A5;
::>                                          *4
end;

begin :: Elementary transformations on vector Matroids

scheme
IndStep { R() -> Ring, P[Matrix of R()],
          A() -> Matrix of R() } :
  for Fam being FinSequence of (len A())-Matrices_over R()
  st len Fam > 0 & Fam.1 is elementary_row Matrix of len A(),R()
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A()), R() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A()), R()
      st Fam.(i + 1) = B * Fi)
  for E being Matrix of (len A()), R() st E = Fam.(len Fam)
  holds P[E * A()]
provided
A1: P[A()] and
A2: for A0 being Matrix of R() st P[A0]
    for E being elementary_row Matrix of R()
    st width E = len A0
    holds P[E * A0]
proof
  defpred Q[Nat] means
  for Fam being FinSequence of (len A())-Matrices_over R()
  st len Fam = $1 & len Fam > 0 & Fam.1 is elementary_row Matrix of R()
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A()), R() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A()), R()
      st Fam.(i + 1) = B * Fi)
  for E being Matrix of (len A()), R() st E = Fam.(len Fam)
  holds P[E * A()];
  A3: Q[0];
  A4: for k being Nat st Q[k] holds Q[k + 1]
  proof
    let k be Nat;
    assume A5: Q[k];
    let Fam be FinSequence of (len A())-Matrices_over R();
    assume A6: len Fam = (k + 1)
    & len Fam > 0 & Fam.1 is elementary_row Matrix of R()
    & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A()), R() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A()), R()
      st Fam.(i + 1) = B * Fi);
    let E be Matrix of len A(), R();
    assume A7: E = Fam.(len Fam);
    per cases by NAT_1:3;
    suppose k = 0;
      then A8: len Fam = 1 by A6;
      then 1 in Seg(len Fam) by FINSEQ_1:3;
      then 1 in dom Fam by FINSEQ_1:def 3;
      then Fam.1 in rng Fam by FUNCT_1:3;
      then Fam.1 in (len A())-Matrices_over R();
      then reconsider F1 = Fam.1 as Matrix of (len  A()), R() by MATRIX_1:2;
      A9: width E = len A() by MATRIX_0:24;
      F1 is elementary_row by A6;
      then E is elementary_row by A7,A8;
      hence thesis by A1,A2,A9;
    end;
    suppose A10: k > 0;
      then 0 < 0 + k;
      then A11: 1 <= k by NAT_1:19;
      reconsider GG = Fam|(Seg k) as FinSequence of (len A())-Matrices_over R()
      by FINSEQ_1:18;
      A12: k < len Fam by A6,NAT_1:13;
      A13: len GG = k
      proof
        k <= len Fam by A12;
        then Seg k c= Seg (len Fam) by FINSEQ_1:5;
        then Seg k c= dom Fam by FINSEQ_1:def 3;
        then k in NAT & Seg k = dom (Fam | (Seg k))
        by ORDINAL1:def 12, RELAT_1:62;
        then len GG = k by FINSEQ_1:def 3;
        hence thesis;
      end;
      len GG = k & len GG > 0 & GG.1 is elementary_row Matrix of R()
      & (for i being Nat st 1 <= i & i < len GG
         for Fi being Matrix of (len A()), R() st Fi = GG.i
         ex B being elementary_row Matrix of (len A()), R()
         st GG.(i + 1) = B * Fi)
      proof
        thus len GG = k by A13;
        thus len GG > 0 by A10,A13;
        1 <= 1 & 1 <= k by A11;
        then 1 in Seg k by FINSEQ_1:1;
        then GG.1 = Fam.1 by FUNCT_1:49;
        hence GG.1 is elementary_row Matrix of R() by A6;
        let i be Nat;
        assume A14: 1 <= i;
        assume A15: i < len GG;
        let Fi be Matrix of (len A()), R();
        assume A16: Fi = GG.i;
        i < k by A13,A15;
        then 1 <= i & i <= k by A14;
        then i in Seg k by FINSEQ_1:1;
        then A17: Fam.i = Fi by A16, FUNCT_1:49;
        i < k by A13,A15;
        then i < k + 1 by NAT_1:13;
        then i < len Fam by A6;
        then consider B being elementary_row Matrix of (len A()), R()
        such that
        A18: Fam.(i + 1) = B * Fi
        by A6,A14,A17;
        take B;
        i < k by A13,A15;
        then i+1 <= k by NAT_1:13;
        then 1 <= i+1 & i+1 <= k by A14, NAT_1:13;
        then i+1 in Seg k by FINSEQ_1:1;
        then Fam.(i+1) = GG.(i+1) by FUNCT_1:49;
        hence GG.(i + 1) = B * Fi by A18;
      end;
      then A19: for E9 being Matrix of len A(), R() st E9 = GG.(len GG)
      holds P[E9 * A()] by A5;
      A20: 1 <= k & k <= k + 1 by A11, NAT_1:13;
      then A21: 1 <= k & k <= len Fam by A6;
      then k in Seg (len Fam) by FINSEQ_1:1;
      then k in dom Fam by FINSEQ_1:def 3;
      then Fam.k in rng Fam by FUNCT_1:3;
      then Fam.k in (len A())-Matrices_over R();
      then reconsider Fk = Fam.k as Matrix of (len A()), R() by MATRIX_1:2;
      k < len Fam & Fk = Fam.k by A12;
      then consider B9 being elementary_row Matrix of len A(), R() such that
      A22: Fam.(k + 1) = B9 * Fk
      by A6,A21;
      1 <= k + 1 & k + 1 <= k + 1 by A20, XXREAL_0:2;
      then k + 1 in Seg (k + 1) by FINSEQ_1:1;
      then k + 1 in Seg (len Fam) by A6;
      then k + 1 in dom Fam by FINSEQ_1:def 3;
      then Fam.(k + 1) in rng Fam by FUNCT_1:3;
      then Fam.(k + 1) in (len A())-Matrices_over R();
      then reconsider F9k = Fam.(k + 1) as Matrix of (len A()), R()
      by MATRIX_1:2;
      A23: k in Seg k by A10,FINSEQ_1:3;

      Fk = GG.(len GG) by A13, A23, FUNCT_1:49;
      then A24: P[Fk * A()] by A19;
      width B9 = len A() & len Fk = len A() & width Fk = len A()
      by MATRIX_0:24;
      then A25: width B9 = len Fk & width Fk = len A();
      A26: E = F9k by A6,A7;
      then E = B9 * Fk by A22;
      then A27: E * A() = B9 * (Fk * A()) by A25,MATRIX_3:33;
      width Fk = len A() by MATRIX_0:24;
      then len (Fk * A()) = len Fk by MATRIX_3:def 4;
      then len (Fk * A()) = len A() by MATRIX_0:24;
      then width B9 = len A() & len (Fk * A()) = len A() by MATRIX_0:24;
      then width B9 = len (Fk * A());
      then P[B9 * (Fk * A())] by A2,A24;
      then P[F9k * A()] by A26, A27;
      hence P[E * A()] by A26;
    end;
  end;
  for k being Nat holds Q[k] from NAT_1:sch 2(A3,A4);
  hence thesis;
end;

scheme
IndRREF { R() -> Skew-Field, P[Matrix of R()],
          A() -> Matrix of R() } :
  ex Fam being FinSequence of (len A())-Matrices_over R()
  st len Fam > 0 & Fam.1 is elementary_row Matrix of (len A()),R()
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A()), R() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A()), R()
      st Fam.(i + 1) = B * Fi)
   & (ex E being Matrix of (len A()), R()
      st E = Fam.(len Fam)
       & P[E * A()] & E * A() in_reduced_row_echelon_form)
provided
A1: P[A()] and
A2: for A0 being Matrix of R() st P[A0]
    for E being elementary_row Matrix of R()
    st width E = len A0
    holds P[E * A0]
proof
  consider Fam being FinSequence of (len A())-Matrices_over R() such that
  A3: len Fam > 0 & Fam.1 is elementary_row Matrix of (len A()),R() and
  A4: for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A()),R() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A()),R()
      st Fam.(i + 1) = B * Fi and
  A5: ex B being Matrix of (len A()),R()
      st B = Fam.(len Fam)
       & (B * A()) in_reduced_row_echelon_form
  by Th20;
  take Fam;
  thus len Fam > 0 by A3;
  thus Fam.1 is elementary_row Matrix of (len A()),R() by A3;
  thus for i being Nat st 1 <= i & i < len Fam
       for Fi being Matrix of (len A()), R() st Fi = Fam.i
       ex B being elementary_row Matrix of (len A()), R()
       st Fam.(i + 1) = B * Fi by A4;
  consider E being Matrix of (len A()), R() such that
  A6: E = Fam.(len Fam) & (E * A()) in_reduced_row_echelon_form
  by A5;
  take E;
  for Fam9 being FinSequence of (len A())-Matrices_over R()
  st len Fam9 > 0 & Fam9.1 is elementary_row Matrix of len A(),R()
   & (for i being Nat st 1 <= i & i < len Fam9
      for Fi being Matrix of (len A()), R() st Fi = Fam9.i
      ex B being elementary_row Matrix of (len A()), R()
      st Fam9.(i + 1) = B * Fi)
  for E9 being Matrix of (len A()), R() st E9 = Fam9.(len Fam9)
  holds P[E9 * A()] from IndStep(A1,A2);
  then P[E * A()] by A3,A4,A6;
  hence thesis by A6;
end;

:: First two theorems prove elementary row matrices produce matroid
:: isomorphisms for vector matroids
theorem Th21:
  for A being Matrix of F
  for M being elementary_row Matrix of F
  st width M = len A
  holds vector_matroid A, vector_matroid (M * A) are_isomorphic;
::>                                                           *4

theorem Th22:
  for A being Matrix of m,n,F
  for Fam being FinSequence of m-Matrices_over F
  st len Fam > 0 & Fam.1 is elementary_row Matrix of m,F
  & (for i being Nat st 1 <= i & i < len Fam
     for Fi being Matrix of m,F st Fi = Fam.i
     ex B being elementary_row Matrix of m,F
     st Fam.(i + 1) = B * Fi)
  for E being Matrix of m,F st E = Fam.(len Fam)
  holds vector_matroid A, vector_matroid (E * A) are_isomorphic
proof
  let A be Matrix of m,n,F;
  deffunc F1() = F;
  deffunc A1() = A;
  defpred P[Matrix of F1()] means
  vector_matroid A, vector_matroid $1 are_isomorphic;

  A1: P[A1()];
  A2: for A0 being Matrix of F1() st P[A0]
  for M being elementary_row Matrix of F1()
  st width M = len A0
  holds P[M * A0]
  proof
    let A0 be Matrix of F1();
    assume A3: P[A0];
    let M be elementary_row Matrix of F1();
    assume width M = len A0;
    then vector_matroid A0, vector_matroid (M * A0) are_isomorphic by Th21;
    then vector_matroid (M * A0), vector_matroid A0 are_isomorphic;
    hence P[M * A0] by A3,Th2;
  end;

  A4: len A1() = m by MATRIX_0:25;
  for Fam being FinSequence of (len A1())-Matrices_over F1()
  st len Fam > 0 & Fam.1 is elementary_row Matrix of len A1(),F1()
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A1()), F1() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A1()), F1()
      st Fam.(i + 1) = B * Fi)
  for E being Matrix of (len A1()), F st E = Fam.(len Fam)
  holds P[E * A1()] from IndStep(A1, A2);
  hence thesis by A4;
end;

theorem Th23:
  for A being Matrix of m,n,F
  ex Fam being FinSequence of m-Matrices_over F
  st len Fam > 0 & Fam.1 is elementary_row Matrix of m,F
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of m, F st Fi = Fam.i
      ex B being elementary_row Matrix of m, F
      st Fam.(i + 1) = B * Fi)
   & (ex E being Matrix of m, F
      st E = Fam.(len Fam)
       & vector_matroid A, vector_matroid(E * A) are_isomorphic
       & E * A in_reduced_row_echelon_form)
proof
  let A be Matrix of m,n,F;
  deffunc F1() = F;
  deffunc A1() = A;
  defpred P[Matrix of F1()] means
  vector_matroid A, vector_matroid $1 are_isomorphic;

  A1: P[A1()];
  A2: for A0 being Matrix of F1() st P[A0]
  for M being elementary_row Matrix of F1()
  st width M = len A0
  holds P[M * A0]
  proof
    let A0 be Matrix of F1();
    assume A3: P[A0];
    let M be elementary_row Matrix of F1();
    assume width M = len A0;
    then vector_matroid A0, vector_matroid (M * A0) are_isomorphic by Th21;
    then vector_matroid (M * A0), vector_matroid A0 are_isomorphic;
    hence P[M * A0] by A3,Th2;
  end;

  A4: len A1() = m by MATRIX_0:25;

  ex Fam being FinSequence of (len A1())-Matrices_over F1()
  st len Fam > 0 & Fam.1 is elementary_row Matrix of (len A1()),F1()
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A1()), F1() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A1()), F1()
      st Fam.(i + 1) = B * Fi)
   & (ex E being Matrix of (len A1()), F1()
      st E = Fam.(len Fam)
       & P[E * A1()] & E * A1() in_reduced_row_echelon_form)
  from IndRREF(A1,A2);
  hence thesis by A4;
end;

theorem Th24:
  for A being Matrix of F
  for M being elementary_row Matrix of F
  st width M = len A
  holds vector_matroid A = vector_matroid (M * A);
::>                                             *4,4

theorem Th25:
  for A being Matrix of m,n,F
  for Fam being FinSequence of m-Matrices_over F
  st len Fam > 0 & Fam.1 is elementary_row Matrix of m,F
  & (for i being Nat st 1 <= i & i < len Fam
     for Fi being Matrix of m,F st Fi = Fam.i
     ex B being elementary_row Matrix of m,F
     st Fam.(i + 1) = B * Fi)
  for E being Matrix of m,F st E = Fam.(len Fam)
  holds vector_matroid A = vector_matroid (E * A)
proof
  let A be Matrix of m,n,F;
  deffunc F1() = F;
  deffunc A1() = A;
  defpred P[Matrix of F1()] means
  vector_matroid A = vector_matroid $1;

  A1: P[A1()];
  A2: for A0 being Matrix of F1() st P[A0]
  for M being elementary_row Matrix of F1()
  st width M = len A0
  holds P[M * A0]
  proof
    let A0 be Matrix of F1();
    assume A3: P[A0];
    let M be elementary_row Matrix of F1();
    assume width M = len A0;
    then vector_matroid A0 = vector_matroid (M * A0) by Th24;
    hence P[M * A0] by A3;
  end;

  A4: len A1() = m by MATRIX_0:25;
  for Fam being FinSequence of (len A1())-Matrices_over F1()
  st len Fam > 0 & Fam.1 is elementary_row Matrix of len A1(),F1()
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A1()), F1() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A1()), F1()
      st Fam.(i + 1) = B * Fi)
  for E being Matrix of (len A1()), F st E = Fam.(len Fam)
  holds P[E * A1()] from IndStep(A1, A2);
  hence thesis by A4;
end;

theorem Th26:
  for A being Matrix of m,n,F
  ex Fam being FinSequence of m-Matrices_over F
  st len Fam > 0 & Fam.1 is elementary_row Matrix of m,F
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of m, F st Fi = Fam.i
      ex B being elementary_row Matrix of m, F
      st Fam.(i + 1) = B * Fi)
   & (ex E being Matrix of m, F
      st E = Fam.(len Fam)
       & vector_matroid A = vector_matroid(E * A)
       & E * A in_reduced_row_echelon_form)
proof
  let A be Matrix of m,n,F;
  deffunc F1() = F;
  deffunc A1() = A;
  defpred P[Matrix of F1()] means
  vector_matroid A = vector_matroid $1;

  A1: P[A1()];
  A2: for A0 being Matrix of F1() st P[A0]
  for M being elementary_row Matrix of F1()
  st width M = len A0
  holds P[M * A0]
  proof
    let A0 be Matrix of F1();
    assume A3: P[A0];
    let M be elementary_row Matrix of F1();
    assume width M = len A0;
    then vector_matroid A0 = vector_matroid (M * A0) by Th24;
    hence P[M * A0] by A3;
  end;

  A4: len A1() = m by MATRIX_0:25;

  ex Fam being FinSequence of (len A1())-Matrices_over F1()
  st len Fam > 0 & Fam.1 is elementary_row Matrix of (len A1()),F1()
   & (for i being Nat st 1 <= i & i < len Fam
      for Fi being Matrix of (len A1()), F1() st Fi = Fam.i
      ex B being elementary_row Matrix of (len A1()), F1()
      st Fam.(i + 1) = B * Fi)
   & (ex E being Matrix of (len A1()), F1()
      st E = Fam.(len Fam)
       & P[E * A1()] & E * A1() in_reduced_row_echelon_form)
  from IndRREF(A1,A2);
  hence thesis by A4;
end;

:: Then we can produce a RREF matrix which produces an identical
:: vector matroid. If we permute the columns of the RREF, then we end
:: up with a standard Representation.
theorem
  for M being F-representable Matroid
  for A being Representation of M
  ex B being Representation of M
  st vector_matroid A = vector_matroid B
  & B in_reduced_row_echelon_form;
::>                             *4

begin :: Oxley's theorem

:: Helper theorem which I think is missing from Mizar
theorem
  for A,B being Matrix of R
  st len A = len B :: number of rows in A = number of rows in B
  for i being Nat
  holds Line(A ^^ B, i) = Line(A, i) ^ Line(B, i);
::>                                             *4,4,4,4

theorem
  for A being Representation of M
  st len A <= width A
   & (width A = 0 implies len A = 0)
   & (for i,j being Nat st [i,j] in Indices 1.(R,len A)
      holds 1.(R, len A) * (i,j) = A * (i,j))
  holds A is full;
::>             *4,4,4

theorem Th30:
  ex A being Representation of M
  st A is full;
::>          *4

registration
  let R,M;
  cluster full for Representation of M;
  existence by Th30;
end;

definition
  let R;
  let M; :: be R-representable Matroid;
  let IT be Representation of M;
  attr IT is standard means :Def13:
  1.(R,len IT) ^^ IT represents M;
end;

:: lemma StandardRepr_toMatroid_isBase_X:
theorem Th31:
  for S being Representation of M st S is standard
  holds Seg (len S) is Basis of vector_matroid S;
::>                                            *4

:: lemma Matrix.exists_standardRepr_isBase
theorem Th32:
  for R being Skew-Field
  for A being Matrix of R
  for G being Basis of vector_matroid A
  ex S being Representation of vector_matroid A
  st S is standard
   & len S = card G
   & vector_matroid S = vector_matroid A;
::>                                    *4

theorem Th33:
  for R being Skew-Field
  for M being R-representable Matroid
  ex S being Representation of M
  st S is standard
proof
  let R be Skew-Field;
  let M be R-representable Matroid;
  consider A being Matrix of R such that
  A1: vector_matroid A, M are_isomorphic by Def4;
  A represents M by A1;
  then reconsider A as Representation of M by Def6;
  set G = the Basis of vector_matroid A;
  consider S being Representation of vector_matroid A such that
  A2: S is standard and
  A3: len S = card G
   & vector_matroid S = vector_matroid A
  by Th32;
  S represents M by A3,Def6,Def5;
  then reconsider S1 = S as Representation of M by Def6;
  take S1;
  1.(R,len S) ^^ S represents vector_matroid A by A2;
  then 1.(R,len S) ^^ S is Representation of vector_matroid A by Def6;
  then 1.(R,len S) ^^ S represents M by A1,Th10;
  then 1.(R,len S1) ^^ S1 represents M;
  hence S1 is standard;
end;

registration
  let R be Skew-Field;
  let M be R-representable Matroid;
  cluster standard for Representation of M;
  existence by Th33;
end;

begin :: Totally unimodular matrices
:: Determinants are defined (meaningfully) for matrices over
:: commutative rings
reserve R for commutative Ring;

registration
  cluster empty finite without_zero for Subset of NAT;
  existence
  proof
    {} NAT is Subset of NAT;
    hence thesis;
  end;
  cluster non empty finite without_zero for Subset of NAT;
  existence
  proof
    reconsider b1 = {1} as Subset of NAT;
    take b1;
    b1 is without_zero by FINSEQ_1:2;
    hence thesis;
  end;
end;

definition
  let R;
  let k be Nat;
  let IT be Matrix of R;
  attr IT is k-partially-unimodular means
  for cs,rs being finite without_zero Subset of NAT
  st rs c= Seg (width IT) & card rs = k
   & cs c= Seg (len IT) & card cs = k
  for A being Matrix of k,R st A = Segm(IT,rs,cs)
  holds Det A = 1.R or Det A = 0.R or Det A = - 1.R;
end;

definition
  let R;
  let IT be Matrix of R;
  attr IT is totally-unimodular means
  for k being Nat
  st k <= min(len IT, width IT)
  holds IT is k-partially-unimodular;
end;

:: Tell Mizar that the identity matrix is totally unimodular
registration
  let R;
  let n be Nat;
  cluster 1.(R,n) -> totally-unimodular;
  correctness;
::>         *4
end;

definition
  let R;
  let IT be Matrix of R;
  attr IT is TU-preserving means
  for A being Matrix of R st A is totally-unimodular
  holds (width IT = len A implies IT*A is totally-unimodular)
  & (width A = len IT implies A*IT is totally-unimodular);
end;

theorem Th34:
  for m,n being Nat
  for l,k being Nat
  holds InterchangeLine(1.(R,m), l, k) is TU-preserving;
::>                                                   *4,4

theorem Th35:
  for m,l being Nat
  for a being Element of R st a <> 0.R
  holds ScalarXLine(1.(R,m), l, a) is TU-preserving;
::>                                               *4,4,4,4

theorem Th36:
  for m,l,k being Nat
  for a being Element of R st a <> 0.R
  holds RlineXScalar(1.(R,m), l, k, a) is TU-preserving;
::>                                                   *4,4,4,4


theorem Th37:
  for m,l,k being Nat st l in 1.(R,m) & k in 1.(R,m)
  holds InterchangeCol(1.(R,m), l, k) is TU-preserving;
::>                                                  *4,4

registration
  let R;
  cluster elementary_row -> TU-preserving for Matrix of R;
  correctness by Th34,Th35,Th36,Th37;
::>            *4,4,4,4
end;

theorem
  for m,n being Nat
  for R being Field
  for A being Matrix of m,n,R st A is totally-unimodular
  for G being Basis of vector_matroid A
  ex S being Representation of vector_matroid A
  st len S = card G
   & S is standard
   & vector_matroid S = vector_matroid A
   & S is totally-unimodular;
::>                        *4

:: lemma Matrix.exists_standardRepr_isBase_isTotallyUnimodular
theorem
  :: for m,n being Nat
  for R being Field
  for A being Matrix of m,n,R st A is totally-unimodular
  for G being Basis of vector_matroid A
  ex S being Representation of vector_matroid A
  st len S = card G
   & S is standard
   & vector_matroid S = vector_matroid A
   & S is totally-unimodular;
::>                        *4

::> 4: This inference is not accepted
